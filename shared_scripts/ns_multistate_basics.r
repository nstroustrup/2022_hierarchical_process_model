library("compiler")
library("rms")
library("boot")
library("rsq")

#takes a data.frame corresponding to a survival_simple.csv file generated by the lifespan machine worm browser software and produces
#a simpler structure useful for comparing the VMC times and lifespan
get_individual_span_from_survival_file = function(data,only_by_hand=T,include_device=T){
	if (only_by_hand){
		by_hand_worms = substring(data$Event.Sources,2,3)=="SS";
		plates_with_by_hand_worms = unique(data$Plate.Name[by_hand_worms])
		d = data[ substring(data$Event.Sources,2,3)=="SS" | data$Censored==1 & data$Plate.Name %in% plates_with_by_hand_worms,]	#second and third character of event sources must be S for "storyboard annotation"
	}else d = data;
	
	d = d[d$Event.Frequency == 1 & (is.na(d$Event.Observation.Type) | d$Event.Observation.Type == ""),]	#only consider single worms--the fast movement cessation time of doubles is unreliable
	
	d = d[!is.na(d$Age.at.Final.Vigorous.Movement..d.) & !is.na(d$Age.at.Final.Movement..d.) & !is.na(d$Age.at.Death.Associated.Expansion..d.),]
	
	d = d[is.na(d$Special.Flag) || d$Special.Flag != "Animal exploded",]
	
	d$Age.at.Final.Vigorous.Movement..d.[d$Censored==1] = d$Age.at.Death..d.[d$Censored==1];	#censoring events aren't outputted with final quick movement data
	#browser()
	m = data.frame(group=d$group,Plate.Name=d$Plate.Name,Group.ID=d$Animal.ID,
			Censored = d$Censored,
			movement_cessation = d$Age.at.Final.Movement..d. - d$Age.at.First.Plate.Observation..d.,
			expansion = d$Age.at.Death.Associated.Expansion..d. - d$Age.at.First.Plate.Observation..d.,
			slow_age = d$Age.at.Final.Vigorous.Movement..d. - d$Age.at.First.Plate.Observation..d.,
			unobserved_period = d$Age.at.First.Plate.Observation..d.)
	
	if ("Experiment" %in% names(d))
		m$Experiment=d$Experiment;
	if ("lbl" %in% names(d))
		m$lbl=d$lbl;
	if ("food" %in% names(d))
		m$food=d$food;
	if ("temperature" %in% names(d))
		m$temperature=d$temperature;
	if ("control" %in% names(d))
		m$control=d$control;
	if(include_device)
		m$Device = d$Device;
		
	if (any(m$movement_cessation[!is.na(m$movement_cessation)] < 0) || any(m$expansion[!is.na(m$expansion)] < 0) || any(m$slow_age[!is.na(m$slow_age)] < 0))
		warning("observation start time is cropping data!");
	#crop any events that happened before observation started.
	
	m$movement_cessation[m$movement_cessation < 0] = 0
	m$expansion[m$expansion < 0] = 0
	m$slow_age[m$slow_age < 0] = 0
	
	m$wrm = paste(m$Plate.Name,m$Group.ID)
	m$e_wrm = paste(m$Experiment,m$Plate.Name,m$Group.ID)
	rows_to_grab = c();
	for (i in unique(m$e_wrm)){
		rows_to_grab = c(which(m$e_wrm==i)[1],rows_to_grab);
	}
	m2 = m[rows_to_grab,]
	mmm = m2$movement_cessation<m2$slow_age
	m2$slow_age[mmm] = m2$movement_cessation[mmm];	#bug with by-hand annotations of slow age time
	
	
	m2$duration_alive_but_nonmoving = m2$expansion-m2$movement_cessation;
	m2$duration_alive_but_nonmoving_crop = m2$duration_alive_but_nonmoving;
	m2$duration_alive_but_nonmoving_crop[m2$duration_alive_but_nonmoving_crop<0]=0;
	m2$duration_changing_posture = m2$movement_cessation-m2$slow_age
	
	m2$status = 1-m2$Censored;
	return(m2);
}

#Fits an AFT model to lifespan and VMC data to estimate batch effects.
#The residuals of this regression can be used as "device adjusted" event times.
ns_span_device_adjustment = function(sp2,adjustment_column = "Device", exclude_movement=F){
	lev = levels(sp2[,adjustment_column]);
	if (is.null(lev)) stop("Can only adjust to factors");
	if (length(lev) == 1){
		sp2$slow_age_v_adj = sp2$slow_age
		if (!exclude_movement)
		sp2$movement_cessation_v_adj = sp2$movement_cessation
		sp2$expansion_v_adj = sp2$expansion
		if (!exclude_movement)
		sp2$movement_cessation_m_adj = sp2$movement_cessation
		sp2$expansion_m_adj = sp2$expansion;
		
		sp2$ev_d = sp2$expansion_v_adj-sp2$slow_age_v_adj
		if (!exclude_movement){
			sp2$em_d = sp2$expansion_m_adj-sp2$movement_cessation_m_adj
			sp2$mv_d = sp2$movement_cessation_v_adj-sp2$slow_age_v_adj
		}
		return(list(spans=sp2,slow_age_model=NA,movement_cessation_model = NA))
	}
	vr = ns_single_bj_group(Surv(sp2$slow_age,1-sp2$Censored)~sp2$Device);
	if (!exclude_movement){
		mr = ns_single_bj_group(Surv(sp2$movement_cessation,1-sp2$Censored)~sp2$Device);
	}else mr = NA;
	v_cf = vr$coefficients
	
	if (!exclude_movement)
		m_cf = vr$coefficients
	sp2$slow_age_v_adj = 0
	
	if (!exclude_movement)
		sp2$movement_cessation_v_adj = 0
	sp2$expansion_v_adj = 0
	
	if (!exclude_movement){
		sp2$movement_cessation_m_adj = 0
		sp2$expansion_m_adj = 0
	}
	for (i in 1:(dim(v_cf)[1])){
		cur = sp2$Device==as.character(v_cf$bj_group[i])
		sp2$slow_age_v_adj[cur] = 		sp2$slow_age[cur]*exp(-v_cf$coefficient[i])
		if (!exclude_movement)
			sp2$movement_cessation_v_adj[cur] = 	sp2$movement_cessation[cur]*exp(-v_cf$coefficient[i])
		sp2$expansion_v_adj[cur] = 		sp2$expansion[cur]*exp(-v_cf$coefficient[i])
		if (!exclude_movement){
			sp2$movement_cessation_m_adj[cur] = 	sp2$movement_cessation[cur]*exp(-m_cf$coefficient[i])
			sp2$expansion_m_adj[cur] = 		sp2$expansion[cur]*exp(-m_cf$coefficient[i])
		}
	}
	sp2$ev_d = sp2$expansion_v_adj-sp2$slow_age_v_adj
	if (!exclude_movement){
		sp2$em_d = sp2$expansion_m_adj-sp2$movement_cessation_m_adj
		sp2$mv_d = sp2$movement_cessation_v_adj-sp2$slow_age_v_adj
	}
	return (list(spans=sp2,slow_age_model=vr,movement_cessation_model = mr));
}

slope_not_one = function(formula, data, indicies,family){
	d = data[indicies,]
	data_dist <<- suppressWarnings(datadist(d));
	options(datadist="data_dist")
	reg = Glm(formula,data=d,family=family);
	return(1-reg$coefficients[2])
}

quantify_relationship = function(reg_formula,dev_adj_formula,data_f,fam,label,calc_boot){
  options(datadist=NULL)
  data_dist <<- suppressWarnings(datadist(data_f));
	options(datadist="data_dist")

	tryCatch(
        {
            
          	reg = Glm(reg_formula,data=data_f,family=fam,x=T);
          	sm = summary(reg)
          	an = anova(reg)
          	ci = confint.default(reg)
          #	print(reg_formula)
          #	print(dev_adj_formula)
          #	print(names(data_f))
          	data_f <<- data_f #rsq has some problem with scoping; so we force it.
          	rsq_res = rsq(reg);
          	if (!is.null(dev_adj_formula)){
          		reg2 = Glm(dev_adj_formula,data=data_f,family=fam);
          		#generates warnings because we are passing Glm rather than glm
          		partial_rsq = rsq.partial(reg,reg2,adj=T,type='v');
          	}else{
          		partial_rsq = NA;
          	}
          	err_f = NA
  	},
        error=function(cond) {
        	print(paste0("Error in quantify_relationship(): ",cond))
        
        	g = data.frame(stage=label,				   
        	               val = NA,
        	               val_li=NA,
        	               val_ui=NA,
        	               intercept = NA,
        	               intercept_li=NA,
        	               intercept_ui=NA,
        	               p_not_zero=NA,
        	               rsq = NA,
        	               partial_rsq = NA,
        	               N = dim(data_f)[1]);
        	if (calc_boot){
        	  
        	  g$diff_val = NA;
        	  g$diff_li=  NA;
        	  g$diff_ui=  NA;
        	  g$diff_p= NA;
        	}
        	err_f <<- g;
        })
    if (!is.na(err_f))return(err_f);
	 
	g = data.frame(stage=label,				   
		      val = reg$coefficients[2],
		      val_li=ci[2,1],
		      val_ui=ci[2,2],
		      intercept = reg$coefficients[1],
		      intercept_li=ci[1,1],
		      intercept_ui=ci[1,2],
		      p_not_zero=an[1,3],
		      partial_rsq = NA,
		      rsq = rsq_res,
		      N = dim(data_f)[1]);
  
  if (!any(is.na(partial_rsq)))
    g$partial_rsq = partial_rsq$partial.rsq

	if (calc_boot){
		rx_b = boot(formula=reg_formula,
			data=data_f,R=10000,
			statistic=slope_not_one,
			family=fam) 
		bci = boot.ci(rx_b,type="bca")
		g$diff_val = mean(rx_b$t);
		g$diff_li= bci$bca[4]	
		g$diff_ui= bci$bca[5]	
		g$diff_p=mean(rx_b$t<=0);
	}
	return(list(results=g,reg=reg));
}